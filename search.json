[{"title":"云叔调戏","url":"/2020/06/07/云叔调戏/","content":"\n![云舒](2020-06-07 22-07-12屏幕截图.png)\n","tags":["群里的那些事"]},{"title":"A酱看三上悠呀大战冲田杏梨","url":"/2020/06/07/2020/三上悠呀大战冲田杏梨/","content":"\n## 震惊！！！\n##### A酱看完三上悠呀大战冲田杏梨后的第一句话是...\n\n![A酱看完三上悠呀大战冲田杏梨](img1.jpg)\n\n![奇怪的知识增加了](QQ图片20200607220508.png)\n\n![小呆呆](QQ图片20200607220543.jpg)\n","tags":["三上悠呀"]},{"title":"妮妮日常装逼之Prolog排序","url":"/2018/05/02/2018/妮妮日常装逼之Prolog排序/","content":"\nProlog排序\n![](1图片1.png)\n![](2图片2.png)\n![](3图片3.png)\n![](4图片4.png)\n![](5图片5.png)\n![](6图片6.png)\n\n","tags":["prolog"]},{"title":"妮妮讲Prolog之DCG与parser","url":"/2018/03/01/2018/妮妮讲Prolog之DCG与parser/","content":"\n\n\n每日一条Prolog小知识：应阿兰之邀，来讲讲dcg做简单的parser。\n\n用dcg做parser，只需描述语法，然后就自动粗来一只吊炸天的parser啦。\n\n今天用swi做例子，注意启动的时候要加上--triditional参数\n\ndcg == definite clause grammar\n\nswi prolog 7对字符串使用了新的类型和操作方法\n\n所以要加上--triditional\n\n加上这个参数后，就和sicstus一样啦\n\n辣么我们今天就用一个例子来讲解\n\n首先我们parse正整数，然后 parse 四则运算并计算\n\n辣么，首先来parse单个数字\n\n``` prolog\nnum1 ::= 0|1|2|3|4|5|6|7|8|9\n```\n意思是，一个数字，可以是0-9的每一个字\n\n![图1](图片1.png)\n\n对应的dcg代码要这么写\n\n--> 是dcg专用符号\n\n左边是谓词的头部\n\n右边是对语法的描述\n\n每个dcg谓词最后都多带两个参数\n\nnum1编译后是这个样子。\n\n![图2](图片2.png)\n\n辣么让我们来parse\n\n![图3](图片3.png)\n\nparse \"345\"这个字符串，\"3\"刚好是一个数字，剩余的在Rest\n\n![图4](图片4.png)\n\n开头空格不是数字，所以不符合语法，fail\n\n![图5](图片5.png)\n\n结尾是空，于是把语言的所有可能都整出来了。\n\n字符串是list，所以\"0\"也就是[48]/\n\n辣么我们来parse一个完整的整数\n\n但是我们先不计算它的值\n\n```prolog\nsimple_num ::= \n   num1\n  | num1 simple_num\n```\n  \n![图6](图片6.png)\n\n没有少\n|代表或者\na ::= b表示，a这个东西，可以被替换成b\n\n辣么，假设simple_num对应345\nnum1是单个数字\nnum1 simple_num是指，num1后面接一个simple_num\n空格是链接\n意思是，345相当于num1(3) simple_num(45)，相当于num1(3) num1(4) simple_num(5)，相当于num1(3) num1(4) num1(5)。不想画图了，就这么简单的来讲吧。\n\n这样吧，我做个parse_tree版本\n\n![图7](图片7.png)\n\n 这是生成parse tree的版本\n\n也就是把刚才的那个奇怪的式子\n\n变成树形结构\n\n你看，就是简单的照着翻译哦\n\n![图8](图片8.png)\n\n效果是这样子的，如果不指定Rest，那么3, 34,345全都是整数，于是所有可能都列出来来\n\n![图9](图片9.png)\n\n辣么，简单的simple_num，照着翻译即可\n\n![图10](图片10.png)\n\n要注意的是，最后还是带哪两个参数，第一个是输入的字符串，第二个是消耗掉以后剩余的部分。\n\nswi支持lazy list，这种方法可以直接用来parse网络数据流文件流等各种流\n\n逼格网的爬虫也可以用这种方法一遍传输局，一遍解析\n\n辣么我们来加点计算，让\"345\"变成数字345。\n\n![11](图片11.png)\n\n![12](图片12.png)\n\n当然要一个初始值0，下边提供了\n\n大括号是dcg专用符号\n\n里面的代码不受dcg规则的影响\n\n大括号外面的代码受dcg规则影响\n\n无论如何都会带上两个参数\n\n![13](图片13.png)\n\n根据消耗的不同，得出不同的数字\n\n这里用了十分简单的一个尾递归啦\n\n![图14](图片14.png)\n\nnum/3, num/4（注意省略的两个参数实际上还是在的）\n这个A用于保存num1的返回值\n基本思路是，每parse到一个字符，就累计一下\n\n![图15](图片15.png)\n\n![图16](图片16.png)\n\n不是，这叫unification\n\n现在来说空格\n\n空格简单的这样来定义吧。\nws ::= \" \" ws |  \"\"\n\n![图17](图片17.png)\n\n直接使用是这个样子\n\n![图18](图片18.png)\n\n意思是，要么是空白什么都没有（后边部分），要么是一个空格外加一个ws\n\n辣么我们现在来计算四则运算表达式\n首先我们这样定义四则运算表达式\n\n![图19](图片19.png)\n\n辣么，为了让他能适应更强的场景，比方说我们可以在数字和符号中间加空格，前后也可以加空格\n辣么可以这样来\n\n![20](图片20.png)\n\n注意ws也包括空字符串\n\n![21](图片21.png)\n\n辣么，照着翻译就行啦\n\n每一个都是第一行描述语法，第二行大括号做计算\n实际使用是这样子的\n\n![22](图片22.png)\n\n注意最后一个\n    34  + 4也是合法的表达式，所以也被尝试了\n\n![23](图片23.png)\n\n\n----------------------------------------------------------------\n\n```prolog\nnum1(0) --> \"0\".\nnum1(1) --> \"1\".\nnum1(2) --> \"2\".\nnum1(3) --> \"3\".\nnum1(4) --> \"4\".\nnum1(5) --> \"5\".\nnum1(6) --> \"6\".\nnum1(7) --> \"7\".\nnum1(8) --> \"8\".\nnum1(9) --> \"9\".\n\nnum(Acc, X) -->\n        num1(X1),\n        { X is Acc * 10 + X1 }.\nnum(Acc, X) -->\n        num1(A),\n        { Acc1 is Acc * 10 + A },\n        num(Acc1, X).\nnum(X) -->\n        num(0, X).\n\n\nsimple_num -->\n        num1(_).\nsimple_num -->\n        num1(_),\n        simple_num.\n\n\n\nws --> \" \", ws.\nws --> \"\".\n\n\n\ncalc(X) -->\n        ws, num(A), ws, \"+\", ws, num(B), ws,\n        { X is A + B }.\ncalc(X) -->\n        ws, num(A), ws, \"-\", ws, num(B), ws,\n        { X is A - B }.\ncalc(X) -->\n        ws, num(A), ws, \"*\", ws, num(B), ws,\n        { X is A * B }.\ncalc(X) -->\n        ws, num(A), ws, \"/\", ws, num(B), ws,\n        { X is A / B }.\n\n\nnum1_parsetree(num1(0)) --> \"0\".\nnum1_parsetree(num1(1)) --> \"1\".\nnum1_parsetree(num1(2)) --> \"2\".\nnum1_parsetree(num1(3)) --> \"3\".\nnum1_parsetree(num1(4)) --> \"4\".\nnum1_parsetree(num1(5)) --> \"5\".\nnum1_parsetree(num1(6)) --> \"6\".\nnum1_parsetree(num1(7)) --> \"7\".\nnum1_parsetree(num1(8)) --> \"8\".\nnum1_parsetree(num1(9)) --> \"9\".\n\nsimple_num_parsetree(simple_num(X)) -->\n        num1_parsetree(X).\nsimple_num_parsetree(simple_num(X, Y)) -->\n        num1_parsetree(X),\n        simple_num_parsetree(Y).\n```\n","tags":["prolog"]},{"title":"历史的见证","url":"/2017/06/07/历史的见证/","content":"\nLisp社区官方QQ群的一些历史见证\n![](QQ图片20200607095444.png)\n![](QQ图片20200607095449.jpg)\n![](QQ图片20150126185638.png)\n![](QQ截图20150207112420.png)\n![](QQ图片20150101102834.jpg)\n![](QQ截图20141217111655.png)\n![](QQ截图20150127095529.png)\n![](QQ图片20150109112211.jpg)\n![](QQ图片20150129094844.png)\n![](QQ图片20150216122508.jpg)\n![](QQ图片20141205103808.jpg)\n![](QQ图片20150120094816.png)\n![](QQ截图20150109112753.png)\n![](QQ图片20150126185420.jpg)\n![](QQ图片20150211100229.jpg)\n![](QQ图片20141217160811.jpg)\n![](QQ图片20141217111629.jpg)\n![](QQ截图20150129162132.png)\n![](QQ图片20141217183352.jpg)\n![](QQ图片20150109112653.png)\n![](QQ截图20150310124055.png)\n![](3f23sss.png)\n![](QQ截图20150126185201.png)\n![](QQ图片20150227191103.jpg)\n![](QQ截图20150209101944.png)\n![](QQ图片20150119120832.jpg)\n![](QQ图片20150216135349.jpg)\n![](QQ图片20150304104450.jpg)\n![](QQ图片20150127095652.jpg)\n![](QQ截图20150127095826.png)\n![](QQ截图20150119102419.png)\n![](QQ图片20150128175649.png)\n![](QQ图片20150119121906.jpg)\n![](QQ图片20150202154546.jpg)\n![](QQ图片20150119121915.jpg)\n![](QQ图片20150325151618.jpg)\n![](QQ图片20150321165645.png)\n![](QQ截图20150122151617.png)\n![](QQ图片20141203102141.jpg)\n![](QQ截图20150126191319.png)\n![](QQ图片20150209101009.png)\n![](QQ图片20150127095607.png)\n![](QQ图片20141208102906.jpg)\n![](QQ图片20150130095710.jpg)\n![](QQ图片20150119121332.jpg)\n![](QQ截图20150128100522.png)\n![](QQ图片20150207112054.png)\n![](QQ图片20150215100316.jpg)\n![](QQ图片20150120094846.png)\n![](QQ图片20150120094840.jpg)\n![](QQ图片20150109112701.jpg)\n![](QQ截图20141202165231.png)\n![](QQ截图20141201133316.png)\n![](QQ截图20150116115937.png)\n![](QQ截图20141222161757.png)\n![](QQ截图20150126185040.png)\n![](QQ截图20150207113345.png)\n![](QQ截图20141126152408.png)\n![](QQ截图20150211094707.png)\n![](QQ图片20141028142834.jpg)\n![](QQ截图20150207113303.png)\n![](QQ图片20150202154527.jpg)\n![](QQ截图20141020151625.png)\n![](QQ图片20150127095802.jpg)\n![](QQ截图20150126185025.png)\n![](QQ图片20150127095645.jpg)\n![](QQ截图20150210184633.png)\n![](QQ图片20150127094802.png)\n![](QQ图片20150126185208.png)\n![](111.png)\n![](QQ图片20150107102951.jpg)\n![](QQ图片20150227191127.jpg)\n![](QQ图片20150212191326.jpg)\n![](QQ图片20141215094901.jpg)\n![](QQ图片20150109112331.jpg)\n![](QQ截图20150207113228.png)\n![](QQ图片20141122114111.jpg)\n![](QQ图片20141208102858.jpg)\n![](QQ截图20141217160823.png)\n![](QQ图片20150120124801.jpg)\n![](QQ截图20150213133950.png)\n![](QQ图片20150212140319.png)\n![](QQ图片20150129135007.jpg)\n![](QQ图片20150130095654.jpg)\n![](QQ图片20150303163346.jpg)\n![](QQ图片20141203102131.jpg)\n![](QQ图片20150109115427.jpg)\n![](643ea05cjw1enqa58sfyyj20ht0ctjv6.jpg)\n![](QQ截图20150128175902.png)\n![](QQ截图20150210162439.png)\n![](QQ图片20150126185330.png)\n![](QQ图片20150321165603.png)\n![](232324.png)\n![](QQ图片20141023190204.jpg)\n![](QQ图片20150127095615.jpg)\n![](QQ截图20150122151943.png)\n![](QQ截图20150126185513.png)\n![](QQ图片20141217111537.jpg)\n![](QQ图片20141210100920.jpg)\n![](QQ图片20150127095025.png)\n![](QQ图片20141126191408.jpg)\n![](QQ截图20150129161932.png)\n![](QQ图片20150129161741.jpg)\n![](QQ图片20150207112409.jpg)\n![](QQ图片20150127095655.jpg)\n![](QQ截图20141202165247.png)\n![](QQ图片20150211095838.jpg)\n![](QQ截图20150121140829.png)\n![](QQ图片20150228094442.jpg)\n![](QQ图片20150126185121.png)\n![](QQ截图20150126191332.png)\n![](QQ图片20141222111018.jpg)\n![](QQ图片20150130095728.png)\n![](QQ截图20150210190159.png)\n![](QQ截图20150128122716.png)\n![](QQ截图20141201133346.png)\n![](QQ截图20150127094715.png)\n![](QQ截图20150209102007.png)\n![](QQ图片20150117165031.jpg)\n![](QQ图片20141122114014.jpg)\n![](QQ图片20150304174130.jpg)\n![](12311.png)\n![](QQ图片20141217111725.jpg)\n![](QQ图片20141205103826.jpg)\n![](QQ图片20150209183153.jpg)\n![](QQ截图20150128093436.png)\n![](QQ截图20150126190924.png)\n![](QQ图片20150128174935.jpg)\n![](QQ截图20141030094250.png)\n![](QQ截图20150109112620.png)\n![](QQ截图20150129094859.png)\n![](QQ图片20150207113217.jpg)\n![](QQ图片20150326191830.png)\n![](QQ图片20141122113731.jpg)\n![](QQ截图20150109115536.png)\n![](QQ图片20141201125935.jpg)\n![](QQ图片20141126191940.jpg)\n![](QQ截图20150126191039.png)\n![](QQ图片20141223093940.jpg)\n![](QQ截图20141211122700.png)\n![](QQ截图20150212191634.png)\n![](QQ截图20150121140750.png)\n![](QQ截图20150127095841.png)\n![](QQ图片20141230191930.jpg)\n![](QQ截图20150130133913.png)\n![](QQ截图20150122151955.png)\n![](QQ图片20150227191118.jpg)\n![](QQ图片20150121171024.jpg)\n![](QQ图片20141201125430.jpg)\n![](QQ截图20150107094010.png)\n![](QQ图片20150127095728.png)\n![](QQ截图20150313185626.png)\n![](QQ图片20150109115416.jpg)\n![](2324.png)\n![](QQ图片20141029152651.jpg)\n\n\n","tags":["群里的那些事"]},{"title":"如何学习CommonLisp?","url":"/2017/06/07/2017/如何学习CommonLisp/","content":"\n\n很遗憾，Common Lisp这门语言，各种都市传说实在是太多了，学习之前，先要忘掉过往所学的知识。\n\n首先明确一点，写Common Lisp代码的时候，首选的写法是和C、Java一样的命令式写法，过往的经验是完全用得上的。\n\n其次，Common Lisp的代码不是数据。Common Lisp只有在像编译器那样子工作的时候，代码会作为数据被输入，这时候才有Code as data（代码 **作为** 数据），但是试问哪个编译器不是如此呢？\n\n第三，Common Lisp的代码可以是任意lisp object，包括各种不可描述（不可打印出来）的object。\n\n第四，Common LISP 没有什么“公里”一类的东西。\n\n第五，Common LISP被定义为一个交互式的环境，好C这样子很纯粹的仅仅只是一个语言是不一样的。\n\n其他都市神话，太多了，待续……\n\n### 那么怎么学习呢？\n\n很遗憾，目前所有教程，都无法准确的描述Common Lisp这门语言，而只会带给学习者各种各样的误解（其实很多时候作者自己也搞不清楚）。所以，为了脑子里少装一些屎，除了忘掉都市传说以外，还需要靠谱的学习资料。\n\n### 从入门到中级：\n\n入门首选Practical Common Lisp ( gigamonkeys.com/book )。这本书草草的看一遍，重点看几个和语言有关的章节即可，写几个Hello world之类的小程序，学会操作以后，就可以丢掉了。但千万不要简单的知识“丢掉”书而已，连书里面的内容，也请尽量忘记，毕竟基本上是不正确的。选择这本书的目的，是书的内容少，却可以让你体验一下用common Lisp写代码的感觉，后续学习的过程中知道在哪里输入代码，知道怎么执行，也就这样子而已了。\n至于使用什么实现，Lispworks和Allegro CL这两个顶尖的商业实现，提供IDE，无需自己手动做什么配置。（反正你在学会Common Lisp之前就会把它给丢掉了，何必浪费时间去写elisp代码呢？）\n不用担心编程思维什么的，照着C、Java那一套来用没错的。不要学那些垃圾教材那样整天操作几个list还欣欣然，或者整天套一堆map什么的还自以为很FP，这些naive行为尽早丢掉。\n\nPractical Common Lisp 刷完后，可以开始看ANSI 226了。对的，也就是Common Lisp的标准文档，要好好背完，这很重要。Common Lisp是比C++还要复杂繁难的编程语言，整个语言内部错综复杂，只学习不思考，只能好好的背完226，然后反复的拿出来翻来翻去才有可能掌握。\n学习的过程中，切忌脑补，切忌思考，Common Lisp尽管看起来和你们所用的语言很像，写程序也可以按照同样的套路，但是实际上差别是很大的，切忌脑补啊！！！\n\n### 另外，为什么直接看标准文档呢？\n除了这是 **唯一正确** 的资料以外，还有一点是，目前Common Lisp社区，无论是实现还是程序员，都在写标准的Common Lisp程序。这样写出来的程序，便于移植到别的Common Lisp实现。最流行的几个Common Lisp库，也都在提供跨实现的API而已，实际上并没有什么功能。为什么这么做呢？一个很大的原因是，Common Lisp世界，从实现开始就是各种乱七八糟的的问题，不仅仅是bug，还包括功能的残缺，所以当一个不行了，可以用另一个实现补上；而遇到一个实现所不具有的功能的时候，可以换另一个实现补上；等等。举一个实际的例子，你正在写一个标准的Common Lisp程序，你打算用CCL发布，但你用Allegro CL来进行单步调试（是的，职业Common Lisp老程序员是这么做的）。\n另外还有一点是刚才提到的“错综复杂”。Common Lisp不像C++那样，你只学一部分也可以驰骋沙场（C++各部分其实还是可以互相独立的）。内部的错中复杂导致的问题是，随便一个东西，都会牵扯到一大堆东西，然后继续牵扯一大堆东西，所以只学一部分，很快就会遇到“坑”了。坑什么的其实都是不存在的，只有自己脑补出来的东西和实际情况不符合的时候，才被评价为“坑”（说到底还是自己读书少嘛）。\n\n啃完226以后（反正你是啃不完的），Common Lisp才算真正入门。\n\n2017 by nini \n\n\n","tags":["CommonLisp"]},{"title":"Lisp群闭包大赛","url":"/2015/08/23/闭包大赛/","content":"\n2015.08.23更新：\n第一次传的数据，由于中途所用的U盘导致损坏（复制到另一台电脑里内容就变了），所以重新上传一次。\n\n大赛使用的数据连接: [data](https://github.com/lisp-nini/Group-Competition/blob/master/data.7z)\n\n由于使用的是同一个U盘，所以下面的入围解也跟着更新（附带的新文件init-solutions内容即为入围解），是否和原来一样，取决于U盘是否把数据修改过。\n\n入围解如下：\n```js\ndata0    2294281716871\ndata1    2272363489779\ndata2    2596594810173\ndata3    2777816180234\ndata4    2355297325387\ndata5    2736254084807\ndata6    2916001715853\ndata7    2641185727690\ndata8    3244156847776\ndata9    4576372820496\n```\n\n\n另外，原来的问题描述，有个地方是错的：\n\n“该整数是目标函数的值（装入背包物品的 _总重量_）。” 的“总重量”应为“总价值”。不过题目描述中除了此处写错以外，其它地方都体现的是“总价值”，期望不会对你造成太大的困扰。\n\n\n\n总之，抱歉了！\n\n---------------------------------------------------------------------\n说好的物品个数<=1000000。\n\n数据都是随机生成的，时间来不及去做刁钻的数据了，难度怎么样，就看运气了。\n\n每个数据的入围解如下。你解出来的总价值必须超过这个数字，才算入围。怎么样，很简单吧 ^_^\n（新的入围解见上面）\n\n如果有高手很快做出最优解，后续可能会看情况增加难度哦！后续若有增加新数据，物品个数也不会超过100000000个。\n\n期待你的答案！  ^_^\n\n\n---------------------------------------------------------------------\n\n\nP.S. 既然是 lisp中文社区，那么再附上一个提升逼格专用的十分简陋的common lisp写的小程序，用来检查一个输出文件的内容对不对。时间仓促，有没有bug就不清楚了，反正也没做多少测试。\n\n享受不断优化的乐趣吧！   ^_^\n\n\n\n--------------------------------------------------------------------\n\n由于比赛已结束, 附上最后冠军的代码(出自Alan)\n[冠军代码连接](https://github.com/lisp-nini/Group-Competition/blob/master/%E8%83%8C%E5%8C%85%E5%A4%A7%E8%B5%9B%E5%86%A0%E5%86%9B%E4%BB%A3%E7%A0%81prolog%26sicstus.pl)\n\n\n","tags":["闭包大赛"]},{"title":"告诉你真实的CommonLisp的宏","url":"/2013/08/16/2013/告诉你真实的CommonLisp的宏/","content":"\n\n转载请说明来自Lisp中文社区官方群1群（25342018），小妮窝窝（307730136）。\n\nCommon Lisp总共有4种被称为“宏”（macro）的东西。下面分别说说他们的作用（这里仅仅只说编译的事情，而且还很模糊没说是哪种编译器（一个Common Lisp实现必须要实现至少两个不同的编译器，分别对应不同的语义））。总之，为了不把Common Lisp的复杂给显露出来吓跑人，先将就吧。\n\n首先明确一个观点：Common Lisp的所有宏都是极其简陋的编译器hook而已。\n\n## macro \n  - 也就是defmacro所定义的宏，这个宏本身是一个函数。编译器在遇到一个宏调用的时候，把当前的环境（环境在标准里面只是一个玄乎的不明所以的存在，环境访问的API在标准化的过程中被去掉了）和调用时的代码作为参数传给这个函数以调用这个函数，然后把这个函数返回的结果放到原来宏调用的位置，替换原有内容。实际上这货就是个“你的代码->Common Lisp代码”的编译器。说好听这是C宏的“加强版”，因为可以执行复杂的逻辑，实际上它不可能像C的宏那样自由的传入和传出部分代码，并且Common Lisp基本上不给这个功能提供任何便利，基本上也只有一个hook接口了（你必须使用非常原始和复杂的方法去实现你的这个小型编译器）。\n\n## reader macro\n  - Common Lisp的Reader（或者说是一个lexer也可以 ，反正这货就是读入一段文本，然后返回一个这段文本所表示的对象）的hook。reader在扫描到reader macro所设置的对应的字符的时候，就调用这个reader macro（实际上也一样对应个函数），让它去扫描和解析代码，然后返回对应的对象。Common Lisp不给这种功能提供什么便利，并且要根据reader algorithm来编写，要小心编写以避免各种问题。\n  \n## compiler macro  \n  - 这个宏其实用于前端优化。在编译的时候，遇到一段代码，如果这段代码对应的定义了相应的compiler macro，那么可以选择将这段代码传给这个对应的compiler macro（懒得说了，同样是函数），然后把函数返回的结果替换掉原有的代码。这基本上跟defmacro所定义的宏是一样的，就是对应的是不同的hook，并且这种可以控制是否要替换。同样的，不要期望Common Lisp为你这个东西提供一堆便利的工具，你只能自己使用最原始的手段来达成。\n\n## symbol macro\n  - 这是跟简单的C宏类似的东西。他的功能是，看到一个符号，就将这个符号替换成symbol macro对应的其它东西，就像#define AAA BBB一样。\n  \n除了symbol macro，其它几个宏都是Common Lisp编译器的hook。那么既然是编译器（有哪个编译器不是这样？），输入的数据肯定是代码（code as data，代码作为数据），输出的数据也肯定是代码了（code as data）（就算你恶搞随便乱输出，你输出的东西还是被认为是代码）。\n\n这就是Common Lisp“神秘”的宏，也是那句神秘的“code as data”所说的东西。这些宏基本上都是全局性的，你定义了一个，你的所有代码都会受影响（除了宏，Common Lisp还有不少的类似的东西，即使是编译器hook还有一些其它的，比方说eval-when），所以基本上所有的代码（任何语言的代码，因为有了reader macro，你完全可以自己解析各种语言各种形式的源代码；类似的，因为有了reader macro，即使是注释也没有一种到哪里都能用的必然会被认为是注释的注释）都可以认为是Common Lisp代码，而基本上所有Common Lisp代码你都无法知道它究竟是什么意思，因为随时背后都有各种乱七八糟的东西来影响你的代码的真正意义。\n\n如果你是被神化了的“宏”、“code as data”忽悠来的，那么这就是真相。接下来该怎么做，我相信你心里已经有答案了。\n\n2013-08-16 by 小妮\n","tags":["CommonLisp"]}]